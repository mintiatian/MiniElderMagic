<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>🧙をWASDで動かす - スムーズ移動</title>
  <style>
    /* 画面全体を表示領域に */
    #game-area {
      width: 100vw;
      height: 100vh;
      position: relative;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #333; /* HUD文字色が見やすいように背景を追加(任意) */
    }
    /* キャラクター用のスタイル */
    .character {
      position: absolute;
      font-size: 50px;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      /* 中心位置を基準にする場合は、各キャラクターで個別に設定 */
      /* transform: translate(-50%, -50%); */
      text-align: center;
    }
  </style>
</head>
<body>
<div id="game-area"></div>

<!-- スクリプトの読み込み -->
<script type="module">
  import { PlayerBase } from './Script/playerBase.js';
  import { UIHud } from './Script/UIHud.js';
  import { Coin } from './Script/coin_character.js';
  import { Stair } from './Script/Stair.js';
  import { Stage } from './Script/Stage.js';  // 新しく追加したステージ管理クラス

  const gameArea = document.getElementById('game-area');

  // 押下状態を保持するためのオブジェクト
  const pressedKeys = {};

  // プレイヤーとして使用するキャラクターを生成
  const wizard = new PlayerBase(100, 100, 3, '🧙', gameArea);
  wizard.draw();

  // ステージマネージャーを生成
  const stageManager = new Stage(gameArea);

  // 最初のステージの敵を生成
  const enemies = stageManager.createEnemiesForStage(1);

  // HUDの生成
  const hud = new UIHud(gameArea);

  // コインの配列を管理
  let coins = [];

  // デモ用に初期コインを生成
  const initialCoin = new Coin(200, 200, gameArea);
  initialCoin.draw();
  coins.push(initialCoin);

  // 階段を生成
  const stair = new Stair(500, 400, gameArea);
  stair.draw();

  // キーの押下状態を監視
  document.addEventListener('keydown', (event) => {
    const key = event.key.toLowerCase();
    pressedKeys[key] = true;
    
    // 方向キーもWASDにマッピング
    if (key === 'arrowup') pressedKeys['w'] = true;
    if (key === 'arrowdown') pressedKeys['s'] = true;
    if (key === 'arrowleft') pressedKeys['a'] = true;
    if (key === 'arrowright') pressedKeys['d'] = true;
  });
  
  document.addEventListener('keyup', (event) => {
    const key = event.key.toLowerCase();
    pressedKeys[key] = false;
    
    // 方向キーもWASDにマッピング解除
    if (key === 'arrowup') pressedKeys['w'] = false;
    if (key === 'arrowdown') pressedKeys['s'] = false;
    if (key === 'arrowleft') pressedKeys['a'] = false;
    if (key === 'arrowright') pressedKeys['d'] = false;
  });

  // 敵が死んだときにコインを生成する関数
  function createCoinAt(x, y) {
    const coin = new Coin(x, y, gameArea);
    coin.draw();
    coins.push(coin);
  }

  // 1回あたりの理想フレーム時間（ミリ秒）
  const FPS = 60;
  const FRAME_TIME = 1000 / FPS; // 1000ms ÷ 60fps ≈ 16.6667ms

  let lastTime = performance.now();
  let accumulatedTime = 0; // 経過時間をためるための変数

  // フレームごとのループ
  function gameLoop(timestamp) {
    const delta = timestamp - lastTime;
    lastTime = timestamp;
    accumulatedTime += delta;

    while (accumulatedTime >= FRAME_TIME) {
      updateGame();
      accumulatedTime -= FRAME_TIME;
    }
    requestAnimationFrame(gameLoop);
  }

  // ゲームエリア内のすべてのCoinを探す
  function findAllCoins() {
    // ドキュメントから追加されたコインを全て取得
    const coinElements = document.querySelectorAll('.character');
    coins = [];
    
    coinElements.forEach(element => {
      // 絵文字が🪙のものだけがコイン
      if (element.textContent === '🪙') {
        // 対応するCoinオブジェクトを探す処理
        // 簡易実装: 表示されているコインは敵が倒された時に作られるので検出不要
      }
    });
  }

  // ステージが変わったときに呼ばれる関数
  function onStageChange() {
    // 新しいステージ番号でステージを生成
    const currentStage = wizard.playerstatus.stage;
    const enemies = stageManager.createEnemiesForStage(currentStage);
    
    // 階段の位置をランダムに変更
    const maxX = gameArea.clientWidth - 100;
    const maxY = gameArea.clientHeight - 100;
    const newX = Math.random() * maxX + 50;
    const newY = Math.random() * maxY + 50;
    stair.x = newX;
    stair.y = newY;
    stair.draw();
    
    // 階段のタッチフラグをリセット
    stair.touched = false;
    
    // ステージ変更エフェクト
    const stageElement = document.createElement('div');
    stageElement.textContent = `ステージ ${currentStage}`;
    stageElement.style.position = 'absolute';
    stageElement.style.top = '50%';
    stageElement.style.left = '50%';
    stageElement.style.transform = 'translate(-50%, -50%)';
    stageElement.style.fontSize = '48px';
    stageElement.style.fontWeight = 'bold';
    stageElement.style.color = 'white';
    stageElement.style.textShadow = '3px 3px 5px rgba(0, 0, 0, 0.8)';
    stageElement.style.zIndex = '1000';
    stageElement.style.opacity = '0';
    stageElement.style.transition = 'opacity 0.5s ease-in, transform 0.5s ease-in';
    
    gameArea.appendChild(stageElement);
    
    // アニメーション
    setTimeout(() => {
      stageElement.style.opacity = '1';
      stageElement.style.transform = 'translate(-50%, -50%) scale(1.2)';
      
      setTimeout(() => {
        stageElement.style.opacity = '0';
        stageElement.style.transform = 'translate(-50%, -50%) scale(0.8)';
        
        setTimeout(() => {
          if (stageElement.parentNode) {
            stageElement.parentNode.removeChild(stageElement);
          }
        }, 500);
      }, 1500);
    }, 10);
  }

  // 前のフレームで生きていた敵を記録するための配列
  let previousLivingEnemies = [...stageManager.enemies];

  function updateGame() {
    // プレイヤーの入力状態をセット & 更新
    wizard.setKeyState(pressedKeys);
    wizard.update();

    // 各敵にプレイヤーの参照を設定し、更新
    stageManager.enemies.forEach(enemy => {
      if (!enemy.playerTarget) {
        enemy.setPlayerTarget(wizard);
      }
    });
    
    // 敵の更新
    stageManager.updateEnemies();
    
    // 各敵について、前のフレームには生きていたが今は配列にない敵にコインを生成
    const currentEnemies = stageManager.enemies;
    previousLivingEnemies.forEach(prevEnemy => {
      // 現在の敵の配列に含まれていなければ、その敵は倒されたということ
      if (!currentEnemies.includes(prevEnemy)) {
        // コインを敵の位置に生成
        const pos = stageManager.getEnemyPosition(prevEnemy);
        if (pos) {
          createCoinAt(pos.x, pos.y);
        }
      }
    });
    
    // 現在の敵リストを更新
    previousLivingEnemies = [...currentEnemies];
    
    // 全ての敵が倒されていて、階段が表示されていない場合は階段を表示
    if (stageManager.areAllEnemiesDefeated() && !stair.element.style.visibility) {
      stair.element.style.visibility = 'visible';
    }
    
    // 階段の更新と接触判定
    stair.update();
    if (stair.checkCollision(wizard)) {
      if (stair.onTouch(wizard)) {
        // ステージを1上げる
        wizard.playerstatus.nextStage();
        
        // 新しいステージのセットアップ
        onStageChange();
      }
    }

    // コインとプレイヤーの接触判定
    const coinElements = document.querySelectorAll('.character');
    coinElements.forEach(element => {
      if (element.textContent === '🪙') {
        // 各コインに対する参照を持つ必要があるが、
        // ここでは簡易的に位置から判定
        const rect = element.getBoundingClientRect();
        const coinX = rect.left + rect.width / 2;
        const coinY = rect.top + rect.height / 2;
        
        // プレイヤーの位置
        const playerRect = wizard.element.getBoundingClientRect();
        const playerX = playerRect.left + playerRect.width / 2;
        const playerY = playerRect.top + playerRect.height / 2;
        
        // 距離を計算
        const dx = coinX - playerX;
        const dy = coinY - playerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // 40px以内に近づいたらコインを取得
        if (distance < 40) {
          // コインを非表示にする
          element.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
          element.style.transform = 'scale(1.5)';
          element.style.opacity = '0';
          
          // プレイヤーのコインを増やす
          wizard.playerstatus.addCoins(1);
          
          // アニメーション後に要素を削除
          setTimeout(() => {
            if (element && element.parentNode) {
              element.parentNode.removeChild(element);
            }
          }, 300);
        }
      }
    });

    // HUDを更新（プレイヤーのステータスを渡す）
    hud.update(wizard.playerstatus);

    // プレイヤーの攻撃と敵の衝突判定
    const enemyTargets = stageManager.enemies;
    wizard.attacks.forEach((fireBall) => {
      fireBall.update(enemyTargets);
    });
    
    // 敵の攻撃とプレイヤーの衝突判定（敵の内部で処理）
    // すでに各敵のupdateメソッド内で、enemyTarget（プレイヤー）を対象とした衝突判定が行われている
    
    // HPが0になったらゲームオーバー
    if (wizard.status.hp <= 0) {
      // ゲームオーバー処理を追加
      displayGameOver();
    }
  }

  // ゲームオーバー表示関数
  function displayGameOver() {
    // すでにゲームオーバー画面があれば何もしない
    if (document.getElementById('game-over')) return;
    
    // ゲームオーバー要素を作成
    const gameOverElement = document.createElement('div');
    gameOverElement.id = 'game-over';
    gameOverElement.style.position = 'absolute';
    gameOverElement.style.top = '50%';
    gameOverElement.style.left = '50%';
    gameOverElement.style.transform = 'translate(-50%, -50%)';
    gameOverElement.style.fontSize = '60px';
    gameOverElement.style.fontWeight = 'bold';
    gameOverElement.style.color = 'red';
    gameOverElement.style.textShadow = '3px 3px 5px rgba(0, 0, 0, 0.8)';
    gameOverElement.style.zIndex = '1000';
    gameOverElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
    gameOverElement.style.padding = '30px';
    gameOverElement.style.borderRadius = '15px';
    gameOverElement.style.textAlign = 'center';
    gameOverElement.innerHTML = `
      <div>ゲームオーバー</div>
      <div style="font-size: 30px; margin-top: 20px;">ステージ: ${wizard.playerstatus.stage}</div>
      <div style="font-size: 30px;">コイン: ${wizard.playerstatus.coins}</div>
      <div style="font-size: 24px; margin-top: 40px;">リスタートするにはF5キーを押してください</div>
    `;
    
    gameArea.appendChild(gameOverElement);
    
    // ゲームを一時停止する効果（すべての敵を止める）
    stageManager.clearEnemies();
  }
  
  // ゲームループ開始
  requestAnimationFrame(gameLoop);
</script>
</body>
</html>